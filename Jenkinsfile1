pipeline {
  agent any
  tools {
    jdk 'jdk17'
    nodejs 'node18'                // <<< use Node 18 (LTS) for Sonar JS analyzer compatibility
  }
  environment {
    SCANNER_HOME = tool 'sonar-scanner'
  }
  stages {
    stage('Clean Workspace') { steps { cleanWs() } }

    stage('Checkout from Git') {
      steps {
        git branch: 'main', url: 'https://github.com/Saisha-Mahadik/BookMyShow-Project'
        sh 'ls -la'
      }
    }

    // Detect the app dir (contains package.json)
    stage('Detect App Dir') {
      steps {
        script {
          env.APP_DIR = sh(returnStdout: true, script: '''
            set -e
            if [ -f package.json ]; then echo "."; exit 0; fi
            d="$(dirname "$(find . -maxdepth 3 -type f -name package.json | head -n1)")"
            d="${d#./}"
            [ -z "$d" ] && { echo "No package.json found"; exit 1; } || echo "$d"
          ''').trim()
          echo "APP_DIR=${env.APP_DIR}"
        }
      }
    }

    // Install and test with coverage BEFORE Sonar
    stage('Install & Test (Coverage)') {
      steps {
        dir("${APP_DIR}") {
          sh '''
            set -euo pipefail
            npm ci || npm install
            # run tests with coverage; adjust for your runner (jest/mocha/vitest)
            npm test -- --coverage || echo "Tests failed or missing script; ensure coverage/lcov.info is produced"
          '''
        }
      }
    }

    stage('SonarQube Analysis') {
      steps {
        withSonarQubeEnv('sonar-server') {
          dir("${APP_DIR}") {
            sh """
              ${SCANNER_HOME}/bin/sonar-scanner \
                -Dsonar.projectKey=BMS \
                -Dsonar.projectName=BMS \
                -Dsonar.sources=. \
                -Dsonar.exclusions=node_modules/**,dist/**,build/**,coverage/** \
                -Dsonar.javascript.lcov.reportPaths=coverage/lcov.info \
                -Dsonar.typescript.lcov.reportPaths=coverage/lcov.info
            """
          }
        }
      }
    }

    stage('Quality Gate') {
      steps {
        script {
          timeout(time: 20, unit: 'MINUTES') {
            def qg = waitForQualityGate abortPipeline: false, credentialsId: 'Sonar-token'
            echo "Quality Gate: ${qg.status} -> ${qg.description}"
            if (qg.status != 'OK') {
              currentBuild.result = 'FAILURE'   // or 'UNSTABLE' if you want to proceed
              error "Quality Gate failed: ${qg.description}"
            }
          }
        }
      }
    }

    stage('OWASP FS Scan') {
      steps {
        dependencyCheck additionalArguments: '--scan ./bookmyshow --disableAssembly --disableYarnAudit --disableNodeAudit', odcInstallation: 'DP-Check'
        dependencyCheckPublisher pattern: '**/dependency-check-report.xml'
      }
    }

    stage('Trivy FS Scan') {
      steps {
        sh 'trivy fs --scanners vuln --skip-files dependency-check-report.xml . > trivyfs.txt || true'
      }
    }

    stage('Docker Daemon Check') {
      steps {
        sh 'docker info >/dev/null 2>&1 || { echo "ERROR: Docker daemon not reachable from this node"; exit 1; }'
      }
    }

    stage('Docker Build & Push') {
      steps {
        script {
          withDockerRegistry(credentialsId: 'docker', toolName: 'docker') {
            sh """
              echo "Building Docker image..."
              docker build --no-cache -t smdocker168/bms:latest -f ${APP_DIR}/Dockerfile ${APP_DIR}

              echo "Pushing Docker image to registry..."
              docker push smdocker168/bms:latest
            """
          }
        }
      }
    }

    stage('Deploy to Container') {
      steps {
        sh '''
          echo "Stopping and removing old container..."
          docker stop bms || true
          docker rm bms || true

          echo "Running new container on port 3000..."
          docker run -d --restart=always --name bms -p 3000:3000 smdocker168/bms:latest

          echo "Checking running containers..."
          docker ps -a

          echo "Fetching logs..."
          sleep 5
          docker logs bms || true
        '''
      }
    }
  }

  post {
    always {
      emailext attachLog: true,
        subject: "'${currentBuild.result}'",
        body: "Project: ${env.JOB_NAME}<br/>" +
              "Build Number: ${env.BUILD_NUMBER}<br/>" +
              "URL: ${env.BUILD_URL}<br/>",
        to: 'saishamahadik23@gmail.com',
        attachmentsPattern: 'trivyfs.txt'
    }
  }
}

